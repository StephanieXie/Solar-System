<!-- 
< Stephanie Xie >
< Mouse commands: press left & drag to rotate, scroll wheel to zoom, press right & drag to move. >
-->
<!DOCTYPE html>
<head>
<meta charset="utf-8"/> 
<title>Solar System</title>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>

<script>
    var scene, camera, renderer, controls;  // Three.js rendering basics.

    var canvas;  // The canvas on which the image is rendered.

    var pointLight; // Light emitted from the sun.

    var sun, mercury, venus, earth, moon, earthMoon, mars, jupiter, saturnBody, saturnRings, saturn, uranus, neptune, pluto;

    var sunRotationSpeed = 0.00025,

        mercuryOrbitAngle = 0,
        mercuryOrbitRadius = 1320,
        mercuryOrbitSpeed = 0.5,
        mercuryRotationSpeed = 0.00075,

        venusOrbitAngle = 0,
        venusOrbitRadius = 1350,
        venusOrbitSpeed = 0.45,
        venusRotationSpeed = -0.0025,

        earthOrbitAngle = 0,
        earthOrbitRadius = 105,
        earthOrbitSpeed = 0.3,
        earthRotationSpeed = 0.03,

        moonOrbitAngle = 0,
        moonOrbitRadius = 25,
        moonOrbitSpeed = 3,
        moonRotationSpeed = 0.02,

        marsOrbitAngle = 0,
        marsOrbitRadius = 1450,
        marsOrbitSpeed = 0.35,
        marsRotationSpeed = 0.025,

        jupiterOrbitAngle = 0,
        jupiterOrbitRadius = 1600,
        jupiterOrbitSpeed = 0.3,
        jupiterRotationSpeed = 0.05,

        saturnOrbitAngle = 0,
        saturnOrbitRadius = 1950;
        saturnOrbitSpeed = 0.25,
        saturnRotationSpeed = 0.04,

        uranusOrbitAngle = 0,
        uranusOrbitRadius = 2200,
        uranusOrbitSpeed = 0.2,
        uranusRotationSpeed = 0.02,

        neptuneOrbitAngle = 0,
        neptuneOrbitRadius = 2350,
        neptuneOrbitSpeed = 0.15,
        neptuneRotationSpeed = 0.01,

        plutoOrbitAngle = 0,
        plutoOrbitRadius = 2400,
        plutoOrbitSpeed = 0.1,
        plutoRotationSpeed = 0.0009;

    // Create the scene. This function is called once, as soon as the page loads.
    // The renderer has already been created before this function is called.
    function createWorld() {
        
        renderer.setClearColor(0); // Set background color (0, or 0x000000, is black).
        scene = new THREE.Scene(); // Create a new scene which we can add objects to.

        // create lights for the sun
        var frontLight = new THREE.DirectionalLight( 0xffffff, 0.7 );
        var backLight = new THREE.DirectionalLight( 0xffffff, 0.7 );
        var rightSideLight = new THREE.DirectionalLight( 0xffffff, 0.7 );
        var leftSideLight = new THREE.DirectionalLight( 0xffffff, 0.7 );
        var topLight = new THREE.DirectionalLight( 0xffffff, 0.7 );
        var bottomLight = new THREE.DirectionalLight( 0xffffff, 0.7 );
        frontLight.position.set(0, 0, 1);
        backLight.position.set(0, 0, -1);
        rightSideLight.position.set(1, 0, 0);
        leftSideLight.position.set(-1, 0, 0);
        topLight.position.set(0, 1, 0);
        bottomLight.position.set(0, -1, 0);
        scene.add(frontLight);
        scene.add(backLight);
        scene.add(rightSideLight);
        scene.add(leftSideLight);
        scene.add(bottomLight);
        scene.add(topLight);
    
        // create a camera, sitting on the positive z-axis.  The camera is not part of the scene.
        camera = new THREE.PerspectiveCamera(45, canvas.width/canvas.height, 0.1, 7500);
        camera.position.z = 5000; // pull back the camera

        // orbit camera controls
        controls = new THREE.OrbitControls(camera);

        // create a point light to light up the planets
        pointLight = new THREE.PointLight("orange", 2.5);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        // sun
        var sunGeometry = new THREE.SphereGeometry(1300, 50, 50);
        var sunTexture = new THREE.TextureLoader().load("textures/sun.jpg");
        var sunMaterial = new THREE.MeshPhongMaterial( { map: sunTexture } );
        sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // mercury
        var mercuryGeometry = new THREE.SphereGeometry(4, 50, 50);
        var mercuryTexture = new THREE.TextureLoader().load("textures/mercury.jpg");
        var mercuryMaterial = new THREE.MeshPhongMaterial( { map: mercuryTexture } );
        mercury = new THREE.Mesh(mercuryGeometry, mercuryMaterial);
        scene.add(mercury);

        // venus
        var venusGeometry = new THREE.SphereGeometry(11, 50, 50);
        var venusTexture = new THREE.TextureLoader().load("textures/venus.jpg");
        var venusMaterial = new THREE.MeshPhongMaterial( { map: venusTexture } );
        venus = new THREE.Mesh(venusGeometry, venusMaterial);
        scene.add(venus);

        // container for earth and moon
        earthMoon = new THREE.Object3D();
        scene.add(earthMoon);
        //earth
        var earthGeometry = new THREE.SphereGeometry(12, 50, 50);
        var earthTexture = new THREE.TextureLoader().load("textures/earth.jpg");
        var earthMaterial = new THREE.MeshPhongMaterial( { map: earthTexture } );
        earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earthMoon.add(earth);
        //moon
        var moonGeometry = new THREE.SphereGeometry(3, 50, 50);
        var moonTexture = new THREE.TextureLoader().load("textures/moon.jpg");
        var moonMaterial = new THREE.MeshPhongMaterial( { map: moonTexture } );
        moon = new THREE.Mesh(moonGeometry, moonMaterial);
        earthMoon.add(moon);

        // mars
        var marsGeometry = new THREE.SphereGeometry(5, 50, 50);
        var marsTexture = new THREE.TextureLoader().load("textures/mars.jpg");
        var marsMaterial = new THREE.MeshPhongMaterial( { map: marsTexture } );
        mars = new THREE.Mesh(marsGeometry, marsMaterial);
        scene.add(mars);

        // jupiter
        var jupiterGeometry = new THREE.SphereGeometry(132, 50, 50);
        var jupiterTexture = new THREE.TextureLoader().load("textures/jupiter.jpg");
        var jupiterMaterial = new THREE.MeshPhongMaterial( { map: jupiterTexture } );
        jupiter = new THREE.Mesh(jupiterGeometry, jupiterMaterial);
        scene.add(jupiter);

        // saturn
        saturn = new THREE.Object3D();
        scene.add(saturn);
        // saturn planet
        var saturnGeometry = new THREE.SphereGeometry(108, 50, 50);
        var saturnTexture = new THREE.TextureLoader().load("textures/saturn.jpg");
        var saturnMaterial = new THREE.MeshPhongMaterial( { map: saturnTexture } );
        saturnBody = new THREE.Mesh(saturnGeometry, saturnMaterial);
        saturn.add(saturnBody);
        // saturn rings
        var ringGeometry = new THREE.RingGeometry(118, 170, 50, 1);
        var ringTexture = new THREE.TextureLoader().load("textures/saturnRings.png");
        var ringMaterial = new THREE.MeshPhongMaterial( { map: ringTexture } );

        saturnRings = new THREE.Mesh(ringGeometry, ringMaterial);
        saturnRings.rotation.set(-Math.PI/3, 0, 0);
        saturn.add(saturnRings);


        // uranus
        var uranusGeometry = new THREE.SphereGeometry(48, 50, 50);
        var uranusTexture = new THREE.TextureLoader().load("textures/uranus.jpg");
        var uranusMaterial = new THREE.MeshPhongMaterial( { map: uranusTexture } );
        uranus = new THREE.Mesh(uranusGeometry, uranusMaterial);
        scene.add(uranus);

        // neptune
        var neptuneGeometry = new THREE.SphereGeometry(48, 50, 50);
        var neptuneTexture = new THREE.TextureLoader().load("textures/neptune.jpg");
        var neptuneMaterial = new THREE.MeshPhongMaterial( { map: neptuneTexture } );
        neptune = new THREE.Mesh(neptuneGeometry, neptuneMaterial);
        scene.add(neptune);

        // pluto
        var plutoGeometry = new THREE.SphereGeometry(2, 50, 50);
        var plutoTexture = new THREE.TextureLoader().load("textures/pluto.jpg");
        var plutoMaterial = new THREE.MeshPhongMaterial( { map: plutoTexture } );
        pluto = new THREE.Mesh(plutoGeometry, plutoMaterial);
        scene.add(pluto);        
    }

    // Render the scene. This is called for each frame of the animation.
    function render() {
        requestAnimationFrame( render );
        controls.update();

        // rotate sun
        sun.rotation.y += sunRotationSpeed;

        // orbit mercury around sun
        mercury.position.x = -Math.cos(mercuryOrbitAngle * Math.PI/180) * mercuryOrbitRadius; 
        mercury.position.z = Math.sin(mercuryOrbitAngle * Math.PI/180) * mercuryOrbitRadius;
        mercuryOrbitAngle += mercuryOrbitSpeed;
        // rotate mercury
        mercury.rotation.y += mercuryRotationSpeed;

        // orbit venus around sun
        venus.position.x = -Math.cos(venusOrbitAngle * Math.PI/180) * venusOrbitRadius; 
        venus.position.z = Math.sin(venusOrbitAngle * Math.PI/180) * venusOrbitRadius;
        venusOrbitAngle += venusOrbitSpeed;
        // rotate venus
        venus.rotation.y -= venusRotationSpeed;

        // orbit earth around sun
        earthMoon.position.x = -Math.cos(earthOrbitAngle * Math.PI/180) * earthOrbitRadius; 
        earthMoon.position.z = Math.sin(earthOrbitAngle * Math.PI/180) * earthOrbitRadius;
        earthOrbitAngle += earthOrbitSpeed;
        // rotate earth
        earth.rotation.y += earthRotationSpeed;

        // orbit moon around earth
        moon.position.x = -Math.cos(moonOrbitAngle * Math.PI/180) * moonOrbitRadius;
        moon.position.z = Math.sin(moonOrbitAngle * Math.PI/180) * moonOrbitRadius;
        moonOrbitAngle += moonOrbitSpeed;
        // rotate moon
        moon.rotation.y += moonRotationSpeed;

        // orbit mars around sun
        mars.position.x = -Math.cos(marsOrbitAngle * Math.PI/180) * marsOrbitRadius; 
        mars.position.z = Math.sin(marsOrbitAngle * Math.PI/180) * marsOrbitRadius;
        marsOrbitAngle += marsOrbitSpeed;
        // rotate mars
        mars.rotation.y += marsRotationSpeed;

        // orbit jupiter around sun
        jupiter.position.x = -Math.cos(jupiterOrbitAngle * Math.PI/180) * jupiterOrbitRadius; 
        jupiter.position.z = Math.sin(jupiterOrbitAngle * Math.PI/180) * jupiterOrbitRadius;
        jupiterOrbitAngle += jupiterOrbitSpeed;
        // rotate jupiter
        jupiter.rotation.y += jupiterRotationSpeed;

        // orbit saturn around sun
        saturn.position.x = -Math.cos(saturnOrbitAngle * Math.PI/180) * saturnOrbitRadius; 
        saturn.position.z = Math.sin(saturnOrbitAngle * Math.PI/180) * saturnOrbitRadius;
        saturnOrbitAngle += saturnOrbitSpeed;
        // rotate saturn
        saturnBody.rotation.y += saturnRotationSpeed;
        // rotate rings
        saturnRings.rotation.z += saturnRotationSpeed;

        // orbit uranus around sun
        uranus.position.x = -Math.cos(uranusOrbitAngle * Math.PI/180) * uranusOrbitRadius; 
        uranus.position.z = Math.sin(uranusOrbitAngle * Math.PI/180) * uranusOrbitRadius;
        uranusOrbitAngle += uranusOrbitSpeed;
        // rotate uranus
        uranus.rotation.x += uranusRotationSpeed;

        // orbit neptune around sun
        neptune.position.x = -Math.cos(neptuneOrbitAngle * Math.PI/180) * neptuneOrbitRadius; 
        neptune.position.z = Math.sin(neptuneOrbitAngle * Math.PI/180) * neptuneOrbitRadius;
        neptuneOrbitAngle += neptuneOrbitSpeed;
        // rotate neptune
        neptune.rotation.y += neptuneRotationSpeed;

        // orbit pluto around sun
        pluto.position.x = -Math.cos(plutoOrbitAngle * Math.PI/180) * plutoOrbitRadius; 
        pluto.position.z = Math.sin(plutoOrbitAngle * Math.PI/180) * plutoOrbitRadius;
        plutoOrbitAngle += plutoOrbitSpeed;
        // rotate pluto
        pluto.rotation.y += plutoRotationSpeed; 

        renderer.render(scene, camera);
    }

    //----------------------------------------------------------------------------------

    // The init() function is called by the onload event when the document has loaded.
    function init() {
        try {
            canvas = document.getElementById("glcanvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true} );
        }
        catch (e) {
            document.getElementById("canvas-holder").innerHTML = "<h3><b>WebGL is not available.</b><h3>";
            return;
        }
    
        // create world and render scene
        createWorld();
        render();
    }

</script>

</head>
<body onload="init()">
<div id="canvas-holder">
    <canvas id="glcanvas" width="600" height="400"></canvas>
</div>
</body>
</html>